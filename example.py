# pip3 install NLtoPDDL

from NLtoPDDL import NLtoPDDLModel

# initialize model by some API key
model = NLtoPDDLModel(api_key='API_KEY')
# model = NLtoPDDLModel(model='gpt-4', api_key='API_KEY')

# prompt from: https://github.com/GuanSuns/LLMs-World-Models-for-Planning/blob/main/prompts/common/action_description_prompt.txt
prompt = """
You are defining the domain (i.e. preconditions and effects) represented in PDDL format of an AI agent's actions. 
Information about the AI agent will be provided in the domain description. Note that individual conditions in preconditions and 
effects should be listed separately. For example, "object_1 is washed and heated" should be considered as two separate 
conditions "object_1 is washed" and "object_1 is heated". Also, in PDDL, two predicates cannot have the same name even 
if they have different parameters. Each predicate in PDDL must have a unique name, and its parameters must be explicitly 
defined in the predicate definition. It is recommended to define predicate names in an intuitive and readable way.

Domain information:
BlocksWorld is a planning domain in artificial intelligence. The AI agent here is a mechanical robot arm that 
can pick and place the blocks. Only one block may be moved at a time: it may either be placed on the table or 
placed atop another block. Because of this, any blocks that are, at a given time, under another block cannot be moved. 
There is only one type of object in this domain, and that is the block.

Here is an example from the classical BlocksWorld domain for demonstrating the output format.
[EXAMPLE]

[INSERT OTHER PROMPT TECHNIQUES]
"""

# convert prompt to PDDL
pddl_domain = model.convert(prompt)

# output PDDL domain
print(f"PDDL:\n{pddl_domain}")

# library functions
model.convert(prompt) # single conversation
model.convert_batch(prompt) # multiple conversations
model.verify(pddl_domain) # returns boolean and a string containing feedback generated by some external verifier
model.get_predicates(pddl_domain) # extract predicates from generated PDDL domain file
model.get_actions(pddl_domain) # extract actions from generated PDDL domain file
model.get_preconditions(pddl_domain) # extract preconditions from generated PDDL domain file
model.get_effects(pddl_domain) # extract effects from generated PDDL domain file

model.parse_pddl_file("path/blocksworld_experiment.pddl")
model.save_pddl_file(pddl_domain, "path/blocksworld_experiment.pddl")
model.print_pddl_file(pddl_domain)






"""Practical example (BACKPROMPTING MECHANISM)"""
while True:
    # convert prompt to PDDL
    pddl_domain = model.convert(prompt)

    # output PDDL domain
    print(f"PDDL:\n{pddl_domain}")

    verified, feedback = model.verify(pddl_domain)

    if verified:
        print('PDDL seems valid')
    else:
        print('PDDL is invalid', feedback)

    # human-in-the-loop feedback
    user_input = input("Enter 'exit' to finish, or provide additional instructions for refinement: ").strip()
    if user_input.lower() == 'exit':
        break
    else:
        prompt += f'\n{user_input}' + feedback

# save file
model.save_pddl_file(pddl_domain, "path/blocksworld_experiment.pddl")

