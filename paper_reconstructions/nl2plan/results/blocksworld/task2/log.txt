STEP ONE: TYPE EXTRACTION

{'block': 'The individual units that can be picked and placed by the robot arm. They can be stacked or placed on a table.', 'table': 'A flat surface where blocks can be placed. It serves as a base for the blocks.', 'movable_object': 'A meta-type that includes all objects that can be moved by the robot arm, specifically blocks in this case.'}

--------------------
STEP TWO: HIERARCHY CONSTRUCTION

{'object': 'Object is always root, everything is an object', 'children': [{'movable_object': 'A meta-type that includes all objects that can be moved by the robot arm.', 'children': [{'block': 'The individual units that can be picked and placed by the robot arm.', 'children': []}]}, {'table': 'A flat surface where blocks can be placed.', 'children': []}]}

--------------------
STEP THREE: ACTION EXTRACTION

{'pick_block': 'The robot arm picks up a block from the table or from on top of another block. Requires the block to be on the table or on another block and not currently held by the arm. Example: robot_arm picks block_1 from the table.', 'place_on_table': 'The robot arm places a block onto the table. Requires the block to be currently held by the arm. Example: robot_arm places block_1 on the table.', 'place_on_block': 'The robot arm places a block on top of another block. Requires the block to be currently held by the arm and the target block to be on the table or already stacked, and the target block must not be held by the arm. Example: robot_arm places block_1 on block_2.', 'release_block': 'The robot arm releases a block that is currently held. Example: robot_arm releases block_1.', 'pick_and_place_on_table': 'The robot arm picks a block and places it on the table. Requires the block to be on the table or on another block and not currently held by the arm. Example: robot_arm picks block_1 from the table and places it on the table.', 'pick_and_place_on_block': 'The robot arm picks a block and places it on top of another block. Requires the block to be on the table or on another block and not currently held by the arm. Example: robot_arm picks block_1 from the table and places it on block_2.'}

--------------------
STEP FOUR: ACTION CONSTRUCTION

ACTIONS:
{'name': 'pick_block', 'params': OrderedDict({'?b': 'block'}), 'preconditions': '(and\n    (or (on_table ?b) (exists (?b2 - block) (on ?b ?b2))) ; The block is either on the table or on another block\n    (not (held ?b)) ; The block is not currently held by the arm\n)', 'effects': '(and\n    (held ?b) ; The block is now held by the robot arm\n    (not (on_table ?b)) ; The block is no longer on the table\n    (not (on ?b ?b2)) ; The block is no longer on top of another block (for all blocks ?b2)\n)'}
{'name': 'place_on_table', 'params': OrderedDict({'?b': 'block'}), 'preconditions': '(and\n    (held ?b) ; The block is currently held by the robot arm\n)', 'effects': '(and\n    (not (held ?b)) ; The block is no longer held by the robot arm\n    (on_table ?b) ; The block is now on the table\n)'}
{'name': 'place_on_block', 'params': OrderedDict({'?b1': 'block', '?b2': 'block', '?b3': 'block'}), 'preconditions': '(and\n    (held ?b1) ; The block being placed is currently held by the robot arm.\n    (or (on_table ?b2) (on ?b2 ?b3)) ; The target block must be on the table or already stacked.\n    (not (held ?b2)) ; The target block must not be held by the arm.\n)', 'effects': '(and\n    (not (held ?b1)) ; The block being placed is no longer held by the robot arm.\n    (on ?b1 ?b2) ; The block being placed is now on top of the target block.\n)'}
{'name': 'release_block', 'params': OrderedDict({'?b': 'block', '?b2': 'block'}), 'preconditions': '(and\n    (held ?b) ; The block is currently held by the robot arm\n    (or (on_table ?b) (exists (?b2 - block) (on ?b ?b2))) ; The block is being released onto the table or onto another block\n)', 'effects': '(and\n    (not (held ?b)) ; The block is no longer held by the robot arm\n    (or (on_table ?b) (exists (?b2 - block) (on ?b ?b2))) ; The block is now on the table or on another block\n)'}
{'name': 'pick_and_place_on_table', 'params': OrderedDict({'?b': 'block'}), 'preconditions': '(and\n    (or (on_table ?b) (on ?b ?b2)) ; The block is either on the table or on another block\n    (not (held ?b)) ; The block is not currently held by the robot arm\n)', 'effects': '(and\n    (held ?b) ; The block is now held by the robot arm\n    (not (on_table ?b)) ; The block is no longer on the table\n    (not (on ?b ?b2)) ; The block is no longer on top of another block (if it was)\n)'}
{'name': 'pick_and_place_on_block', 'params': OrderedDict({'?b1': 'block', '?b2': 'block', '?b3': 'block'}), 'preconditions': '(and\n    (or (on_table ?b1) (on ?b1 ?b2)) ; ?b1 must be on the table or on another block\n    (not (held ?b1)) ; ?b1 must not be currently held by the robot arm\n    (or (on_table ?b2) (on ?b2 ?b3)) ; ?b2 must be on the table or on another block\n)', 'effects': '(and\n    (held ?b1) ; ?b1 is now held by the robot arm\n    (not (on_table ?b1)) ; ?b1 is no longer on the table\n    (on ?b1 ?b2) ; ?b1 is now on top of ?b2\n)'}

PREDICATES:
{'name': 'on_table', 'desc': 'true if the block ?b is on the table.', 'raw': '(on_table ?b - block): true if the block ?b is on the table', 'params': OrderedDict({'?b': 'block'}), 'clean': '(on_table ?b - block): true if the block ?b is on the table.'}
{'name': 'held', 'desc': 'true if the block ?b is currently held by the robot arm.', 'raw': '(held ?b - block): true if the block ?b is currently held by the robot arm', 'params': OrderedDict({'?b': 'block'}), 'clean': '(held ?b - block): true if the block ?b is currently held by the robot arm.'}
{'name': 'on', 'desc': 'true if block ?b1 is on top of block ?b2.', 'raw': '(on ?b1 - block ?b2 - block): true if block ?b1 is on top of block ?b', 'params': OrderedDict({'?b1': 'block', '?b2': 'block'}), 'clean': '(on ?b1 - block ?b2 - block): true if block ?b1 is on top of block ?b2.'}

--------------------
STEP FIVE: TASK EXTRACTION

OBJECTS:
block1 - block
block2 - block
block3 - block
block4 - block
table1 - table
INITIAL STATES:
(on block1 table1)
(on block2 block1)
(on block3 table1)
(on block4 block3)
GOAL STATES:
(AND 
   (on block1 table1) 
   (on block3 block1) 
   (on block2 block3) 
   (on block4 block2) 
)


PDDL DOMAIN:
(define (domain blocksworld)
   (:requirements
      :strips :typing :equality :negative-preconditions :disjunctive-preconditions :universal-preconditions :conditional-effects)

   (:types 
      movable_object - object
      block - movable_object
      table - object
   )

   (:predicates 
      (on_table ?b - block) ;  true if the block ?b is on the table.
      (held ?b - block) ;  true if the block ?b is currently held by the robot arm.
      (on ?b1 - block ?b2 - block) ;  true if block ?b1 is on top of block ?b2.
   )

   (:action pick_block
      :parameters (
         ?b - block
      )
      :precondition
         (and
             (or (on_table ?b) (exists (?b2 - block) (on ?b ?b2))) ; The block is either on the table or on another block
             (not (held ?b)) ; The block is not currently held by the arm
         )
      :effect
         (and
             (held ?b) ; The block is now held by the robot arm
             (not (on_table ?b)) ; The block is no longer on the table
             (not (on ?b ?b2)) ; The block is no longer on top of another block (for all blocks ?b2)
         )
   )

   (:action place_on_table
      :parameters (
         ?b - block
      )
      :precondition
         (and
             (held ?b) ; The block is currently held by the robot arm
         )
      :effect
         (and
             (not (held ?b)) ; The block is no longer held by the robot arm
             (on_table ?b) ; The block is now on the table
         )
   )

   (:action place_on_block
      :parameters (
         ?b1 - block
         ?b2 - block
         ?b3 - block
      )
      :precondition
         (and
             (held ?b1) ; The block being placed is currently held by the robot arm.
             (or (on_table ?b2) (on ?b2 ?b3)) ; The target block must be on the table or already stacked.
             (not (held ?b2)) ; The target block must not be held by the arm.
         )
      :effect
         (and
             (not (held ?b1)) ; The block being placed is no longer held by the robot arm.
             (on ?b1 ?b2) ; The block being placed is now on top of the target block.
         )
   )

   (:action release_block
      :parameters (
         ?b - block
         ?b2 - block
      )
      :precondition
         (and
             (held ?b) ; The block is currently held by the robot arm
             (or (on_table ?b) (exists (?b2 - block) (on ?b ?b2))) ; The block is being released onto the table or onto another block
         )
      :effect
         (and
             (not (held ?b)) ; The block is no longer held by the robot arm
             (or (on_table ?b) (exists (?b2 - block) (on ?b ?b2))) ; The block is now on the table or on another block
         )
   )

   (:action pick_and_place_on_table
      :parameters (
         ?b - block
      )
      :precondition
         (and
             (or (on_table ?b) (on ?b ?b2)) ; The block is either on the table or on another block
             (not (held ?b)) ; The block is not currently held by the robot arm
         )
      :effect
         (and
             (held ?b) ; The block is now held by the robot arm
             (not (on_table ?b)) ; The block is no longer on the table
             (not (on ?b ?b2)) ; The block is no longer on top of another block (if it was)
         )
   )

   (:action pick_and_place_on_block
      :parameters (
         ?b1 - block
         ?b2 - block
         ?b3 - block
      )
      :precondition
         (and
             (or (on_table ?b1) (on ?b1 ?b2)) ; ?b1 must be on the table or on another block
             (not (held ?b1)) ; ?b1 must not be currently held by the robot arm
             (or (on_table ?b2) (on ?b2 ?b3)) ; ?b2 must be on the table or on another block
         )
      :effect
         (and
             (held ?b1) ; ?b1 is now held by the robot arm
             (not (on_table ?b1)) ; ?b1 is no longer on the table
             (on ?b1 ?b2) ; ?b1 is now on top of ?b2
         )
   )
)

PDDL PROBLEM:
(define
   (problem blocksworld_problem)
   (:domain blocksworld)

   (:objects 
      block1 - block
      block2 - block
      block3 - block
      block4 - block
      table1 - table
   )

   (:init
      (on block1 table1)
      (on block2 block1)
      (on block3 table1)
      (on block4 block3)
   )

   (:goal
      (and 
         (on block1 table1) 
         (on block3 block1) 
         (on block2 block3) 
         (on block4 block2) 
      )
   )

)